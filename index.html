<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FPS Three.js</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: #000;
      font-family: Arial, sans-serif;
    }
    
    #blocker {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      text-align: center;
      z-index: 1000;
    }
    
    #instructions {
      cursor: pointer;
      padding: 40px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 20px;
      max-width: 600px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
    
    #instructions h2 {
      margin: 0 0 20px 0;
      font-size: 2em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    }
    
    #instructions p {
      margin: 10px 0;
      font-size: 1.1em;
    }
    
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: rgba(0, 255, 0, 0.8);
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
    }
    
    #crosshair::before {
      width: 2px;
      height: 20px;
    }
    
    #crosshair::after {
      width: 20px;
      height: 2px;
    }
    
    #ui {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: white;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 10px;
      z-index: 100;
      font-size: 18px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }
    
    #ui span {
      color: #00ff00;
      font-weight: bold;
    }
    
    .reloading {
      color: #ffaa00 !important;
    }
    
    #gameOver {
      display: none;
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 2000;
    }
    
    #gameOver h1 {
      font-size: 4em;
      margin: 0;
      color: #00ff00;
      text-shadow: 0 0 20px #00ff00;
    }
    
    #gameOver button {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 1.5em;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    
    #gameOver button:hover {
      transform: scale(1.1);
    }
  </style>
</head>
<body>
  <div id="blocker">
    <div id="instructions">
      <h2>üéÆ CLIQUE POUR D√âMARRER üéÆ</h2>
      <p><strong>ZQSD ou WASD</strong> - Se d√©placer</p>
      <p><strong>Souris</strong> - Viser</p>
      <p><strong>Clic gauche</strong> - Tirer</p>
      <p><strong>R</strong> - Recharger</p>
      <p style="margin-top: 20px; font-size: 0.9em; opacity: 0.8;">
        √âliminez tous les ennemis rouges !
      </p>
    </div>
  </div>
  
  <div id="crosshair"></div>
  
  <div id="ui">
    <div>Munitions: <span id="ammo">30/30</span></div>
    <div>Ennemis: <span id="enemies">5</span></div>
  </div>
  
  <div id="gameOver">
    <h1>VICTOIRE !</h1>
    <p style="font-size: 1.5em;">Tous les ennemis ont √©t√© √©limin√©s</p>
    <button onclick="location.reload()">Rejouer</button>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    // Configuration du jeu
    const CONFIG = {
      moveSpeed: 8,
      enemySpeed: 0.02,
      bulletSpeed: 80,
      reloadTime: 2000,
      maxAmmo: 30,
      enemyCount: 5
    };

    // Initialisation de la sc√®ne
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

    // Cam√©ra
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    camera.position.set(0, 1.6, 5);

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Lumi√®res
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(20, 30, 20);
    directionalLight.castShadow = true;
    directionalLight.shadow.camera.left = -50;
    directionalLight.shadow.camera.right = 50;
    directionalLight.shadow.camera.top = 50;
    directionalLight.shadow.camera.bottom = -50;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    scene.add(directionalLight);

    // Sol
    const floorGeometry = new THREE.PlaneGeometry(100, 100);
    const floorMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x4a7c59,
      roughness: 0.8
    });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Murs
    const walls = [];
    const wallMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x8b7355,
      roughness: 0.9
    });

    function createWall(x, z, width, depth) {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(width, 4, depth),
        wallMaterial
      );
      wall.position.set(x, 2, z);
      wall.castShadow = true;
      wall.receiveShadow = true;
      scene.add(wall);
      walls.push(wall);
      return wall;
    }

    // P√©rim√®tre de l'ar√®ne
    createWall(0, -25, 50, 1);    // Nord
    createWall(0, 25, 50, 1);     // Sud
    createWall(-25, 0, 1, 50);    // Ouest
    createWall(25, 0, 1, 50);     // Est

    // Obstacles int√©rieurs
    createWall(10, 0, 1, 15);
    createWall(-10, 0, 1, 15);
    createWall(0, 10, 15, 1);
    createWall(0, -10, 15, 1);

    // Ennemis
    const enemies = [];
    const enemyGeometry = new THREE.BoxGeometry(1, 2, 1);
    const enemyMaterial = new THREE.MeshStandardMaterial({ 
      color: 0xff0000,
      emissive: 0x330000
    });

    for (let i = 0; i < CONFIG.enemyCount; i++) {
      const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
      
      // Position al√©atoire sans √™tre trop proche du joueur
      let x, z;
      do {
        x = (Math.random() - 0.5) * 40;
        z = (Math.random() - 0.5) * 40;
      } while (Math.sqrt(x * x + z * z) < 10);
      
      enemy.position.set(x, 1, z);
      enemy.castShadow = true;
      scene.add(enemy);
      enemies.push(enemy);
    }

    // Syst√®me de tir
    const bullets = [];
    let ammo = CONFIG.maxAmmo;
    let isReloading = false;

    function shoot() {
      if (ammo <= 0 || isReloading || !controls.isLocked) return;
      
      ammo--;
      updateUI();
      
      // Cr√©er le projectile
      const bullet = new THREE.Mesh(
        new THREE.SphereGeometry(0.1),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      
      bullet.position.copy(camera.position);
      
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      bullet.velocity = direction.multiplyScalar(CONFIG.bulletSpeed);
      
      scene.add(bullet);
      bullets.push(bullet);
    }

    function reload() {
      if (ammo >= CONFIG.maxAmmo || isReloading) return;
      
      isReloading = true;
      document.getElementById('ammo').classList.add('reloading');
      document.getElementById('ammo').textContent = 'RECHARGEMENT...';
      
      setTimeout(() => {
        ammo = CONFIG.maxAmmo;
        isReloading = false;
        updateUI();
        document.getElementById('ammo').classList.remove('reloading');
      }, CONFIG.reloadTime);
    }

    function updateUI() {
      document.getElementById('ammo').textContent = `${ammo}/${CONFIG.maxAmmo}`;
      document.getElementById('enemies').textContent = enemies.length;
    }

    // Contr√¥les
    const controls = {
      isLocked: false,
      moveForward: false,
      moveBackward: false,
      moveLeft: false,
      moveRight: false
    };

    const blocker = document.getElementById('blocker');
    const crosshair = document.getElementById('crosshair');

    // Pointer Lock
    document.body.addEventListener('click', () => {
      if (!controls.isLocked) {
        document.body.requestPointerLock();
      }
    });

    document.addEventListener('pointerlockchange', () => {
      if (document.pointerLockElement === document.body) {
        controls.isLocked = true;
        blocker.style.display = 'none';
        crosshair.style.opacity = '1';
      } else {
        controls.isLocked = false;
        blocker.style.display = 'flex';
        crosshair.style.opacity = '0';
      }
    });

    // Contr√¥le de la souris
    document.addEventListener('mousemove', (e) => {
      if (!controls.isLocked) return;
      
      const sensitivity = 0.002;
      camera.rotation.y -= e.movementX * sensitivity;
      camera.rotation.x -= e.movementY * sensitivity;
      camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
    });

    // Contr√¥les clavier
    document.addEventListener('keydown', (e) => {
      if (!controls.isLocked) return;
      
      switch (e.code) {
        case 'KeyW':
        case 'KeyZ':
          controls.moveForward = true;
          break;
        case 'KeyS':
          controls.moveBackward = true;
          break;
        case 'KeyA':
        case 'KeyQ':
          controls.moveLeft = true;
          break;
        case 'KeyD':
          controls.moveRight = true;
          break;
        case 'KeyR':
          reload();
          break;
      }
    });

    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW':
        case 'KeyZ':
          controls.moveForward = false;
          break;
        case 'KeyS':
          controls.moveBackward = false;
          break;
        case 'KeyA':
        case 'KeyQ':
          controls.moveLeft = false;
          break;
        case 'KeyD':
          controls.moveRight = false;
          break;
      }
    });

    // Tir avec clic
    document.addEventListener('mousedown', (e) => {
      if (e.button === 0 && controls.isLocked) {
        shoot();
      }
    });

    // D√©tection de collision
    function checkCollision(position) {
      const playerBox = new THREE.Box3(
        new THREE.Vector3(position.x - 0.5, 0, position.z - 0.5),
        new THREE.Vector3(position.x + 0.5, 3, position.z + 0.5)
      );
      
      for (const wall of walls) {
        const wallBox = new THREE.Box3().setFromObject(wall);
        if (playerBox.intersectsBox(wallBox)) {
          return true;
        }
      }
      return false;
    }

    // IA des ennemis
    function updateEnemies() {
      enemies.forEach(enemy => {
        const direction = new THREE.Vector3()
          .subVectors(camera.position, enemy.position)
          .normalize();
        
        const newPos = enemy.position.clone().add(
          direction.multiplyScalar(CONFIG.enemySpeed)
        );
        
        // Simple collision avec murs
        enemy.position.lerp(newPos, 0.5);
      });
    }

    // D√©tection des impacts
    function checkHits() {
      for (let i = bullets.length - 1; i >= 0; i--) {
        const bullet = bullets[i];
        
        for (let j = enemies.length - 1; j >= 0; j--) {
          const enemy = enemies[j];
          
          if (bullet.position.distanceTo(enemy.position) < 1) {
            // Touch√© !
            scene.remove(enemy);
            enemies.splice(j, 1);
            scene.remove(bullet);
            bullets.splice(i, 1);
            updateUI();
            
            // Victoire ?
            if (enemies.length === 0) {
              document.getElementById('gameOver').style.display = 'flex';
              document.exitPointerLock();
            }
            break;
          }
        }
      }
    }

    // Boucle de jeu
    const clock = new THREE.Clock();

    function animate() {
      requestAnimationFrame(animate);
      
      const delta = clock.getDelta();

      if (controls.isLocked) {
        // Mouvement du joueur
        const moveDirection = new THREE.Vector3();
        const forward = new THREE.Vector3();
        const right = new THREE.Vector3();
        
        camera.getWorldDirection(forward);
        forward.y = 0;
        forward.normalize();
        
        right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
        
        if (controls.moveForward) moveDirection.add(forward);
        if (controls.moveBackward) moveDirection.sub(forward);
        if (controls.moveRight) moveDirection.add(right);
        if (controls.moveLeft) moveDirection.sub(right);
        
        moveDirection.normalize();
        moveDirection.multiplyScalar(CONFIG.moveSpeed * delta);
        
        const oldPosition = camera.position.clone();
        camera.position.add(moveDirection);
        
        if (checkCollision(camera.position)) {
          camera.position.copy(oldPosition);
        }
      }

      // Mise √† jour des projectiles
      bullets.forEach((bullet, i) => {
        bullet.position.add(bullet.velocity.clone().multiplyScalar(delta));
        
        if (bullet.position.length() > 200) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      });

      updateEnemies();
      checkHits();
      
      renderer.render(scene, camera);
    }

    // Gestion du redimensionnement
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // D√©marrage
    animate();
  </script>
</body>
</html>
