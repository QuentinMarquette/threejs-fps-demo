<!DOCTYPE html>
<html lang="fr">
<head>
  <title>FPS Three.js - Arme + Tirs + Textures</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body { margin: 0; font-family: Arial; }
    #blocker { position: absolute; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); }
    #instructions { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; font-size: 14px; cursor: pointer; color: white; }
    #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; margin: -10px; pointer-events: none; opacity: 0; }
    #crosshair::before, #crosshair::after { content: ''; position: absolute; background: lime; left: 50%; top: 50%; transform: translate(-50%, -50%); }
    #crosshair::before { width: 2px; height: 20px; }
    #crosshair::after { width: 20px; height: 2px; }
    #ui { position: absolute; bottom: 20px; left: 20px; color: white; background: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; z-index: 100; font-size: 14px; }
  </style>
</head>
<body>
  <div id="blocker">
    <div id="instructions">
      <span style="font-size: 36px">Cliquez pour jouer</span>
      <br />
      (ZQSD = bouger | Souris = regarder | Clic gauche = tirer | R = recharger)
      <br />
    </div>
  </div>

  <div id="crosshair"></div>
  <div id="ui">Munitions: <span id="ammo">30/30</span></div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.168.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.168.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.y = 10;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(1, 1, 1).normalize();
    scene.add(light);

    const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(10, 10);
    const floorMaterial = new THREE.MeshBasicMaterial({ map: floorTexture, color: 0x444444 });
    const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
    floorGeometry.rotateX(-Math.PI / 2);
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    scene.add(floor);

    const wallTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/brick_diffuse.jpg');
    wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
    wallTexture.repeat.set(4, 1);
    const wallMaterial = new THREE.MeshBasicMaterial({ map: wallTexture, color: 0x444444 });

    const objects = [];
    const sphereGeometry = new THREE.SphereGeometry(20, 32, 16);
    for (let i = 0; i < 1000; i++) {
      const cube = new THREE.Mesh(sphereGeometry, wallMaterial);
      cube.position.x = Math.random() * 800 - 400;
      cube.position.y = Math.random() * 800 - 400;
      cube.position.z = Math.random() * 800 - 400;
      cube.rotation.x = Math.random() * 2 * Math.PI;
      cube.rotation.y = Math.random() * 2 * Math.PI;
      cube.rotation.z = Math.random() * 2 * Math.PI;
      cube.scale.x = Math.random() + 0.5;
      cube.scale.y = Math.random() + 0.5;
      cube.scale.z = Math.random() + 0.5;
      scene.add(cube);
      objects.push(cube);
    }

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');
    const crosshair = document.getElementById('crosshair');

    instructions.addEventListener('click', () => controls.lock());
    controls.addEventListener('lock', () => {
      blocker.style.display = 'none';
      crosshair.style.opacity = '1';
    });
    controls.addEventListener('unlock', () => {
      blocker.style.display = 'block';
      crosshair.style.opacity = '0';
    });

    scene.add(controls.getObject());

    const onKeyDown = (event) => {
      switch (event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyD': moveRight = true; break;
        case 'KeyR': reload(); break;
      }
    };

    const onKeyUp = (event) => {
      switch (event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyD': moveRight = false; break;
      }
    };

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);

    // Arme (sprite simple)
    const gunTexture = new THREE.TextureLoader().load('https://opengameart.org/sites/default/files/gun_sprite_preview.png');
    const gunMaterial = new THREE.SpriteMaterial({ map: gunTexture });
    const gun = new THREE.Sprite(gunMaterial);
    gun.position.set(0.3, -0.3, -0.5);
    gun.scale.set(0.2, 0.2, 1);
    camera.add(gun);

    // Tirs
    const bullets = [];
    let currentAmmo = 30;
    let isReloading = false;
    function shoot() {
      if (currentAmmo <= 0 || isReloading) return;
      currentAmmo--;
      updateAmmoUI();
      const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.05), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
      bullet.position.copy(camera.position);
      const direction = new THREE.Vector3();
      camera.getWorldDirection(direction);
      bullet.userData.velocity = direction.multiplyScalar(50);
      scene.add(bullet);
      bullets.push(bullet);
    }
    document.addEventListener('click', shoot);

    function reload() {
      if (isReloading || currentAmmo === 30) return;
      isReloading = true;
      setTimeout(() => {
        currentAmmo = 30;
        updateAmmoUI();
        isReloading = false;
      }, 2000);
    }

    function updateAmmoUI() {
      document.getElementById('ammo').textContent = `${currentAmmo}/30`;
    }

    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let prevTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      velocity.y -= 9.8 * 100.0 * delta;

      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();

      if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

      controls.moveRight(-velocity.x * delta);
      controls.moveForward(-velocity.z * delta);
      controls.getObject().position.y += (velocity.y * delta);

      if (controls.getObject().position.y < 10) {
        velocity.y = 0;
        controls.getObject().position.y = 10;
        canJump = true;
      }

      // Mouvement balles
      bullets.forEach((bullet, i) => {
        bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
        if (bullet.position.length() > 1000) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      });

      prevTime = time;
      renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>