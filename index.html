<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>FPS Three.js - ULTIMATE</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: Arial; }
    #blocker {
      position: absolute; inset: 0; background: rgba(0,0,0,0.9);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      color: white; text-align: center; z-index: 1000;
    }
    #instructions { cursor: pointer; padding: 30px; background: #222; border-radius: 15px; max-width: 500px; }
    #crosshair {
      position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; margin: -10px;
      pointer-events: none; opacity: 0; transition: opacity 0.3s;
    }
    #crosshair::before, #crosshair::after {
      content: ''; position: absolute; background: lime; left: 50%; top: 50%;
      transform: translate(-50%, -50%);
    }
    #crosshair::before { width: 2px; height: 20px; }
    #crosshair::after { width: 20px; height: 2px; }
    #error { color: #ff6b6b; margin-top: 15px; font-size: 0.9em; }
  </style>
</head>
<body>

  <div id="blocker">
    <div id="instructions">
      <h2>Clique pour jouer</h2>
      <p><strong>ZQSD</strong> = déplacer | <strong>Souris</strong> = regarder</p>
      <p id="error"></p>
    </div>
  </div>
  <div id="crosshair"></div>

  <!-- Three.js + PointerLock via CDN -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.168.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // === DÉTECTION file:// + MESSAGE D'ERREUR ===
    const errorDiv = document.getElementById('error');
    if (window.location.protocol === 'file:') {
      errorDiv.innerHTML = 'Pointer Lock bloqué en file:// → <br><strong>Utilise un serveur local</strong> (Live Server, Python, etc.)<br>OU continue : le jeu marchera sans verrouillage souris.';
    }

    // === SCÈNE ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // === CONTRÔLES (Pointer Lock) ===
    const controls = new THREE.PointerLockControls(camera, document.body);
    const blocker = document.getElementById('blocker');
    const instructions = document.getElementById('instructions');
    const crosshair = document.getElementById('crosshair');

    instructions.addEventListener('click', () => {
      controls.lock();
    });

    controls.addEventListener('lock', () => {
      blocker.style.display = 'none';
      crosshair.style.opacity = '1';
    });

    controls.addEventListener('unlock', () => {
      blocker.style.display = 'block';
      crosshair.style.opacity = '0';
    });

    // === SOL ===
    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 50),
      new THREE.MeshStandardMaterial({ color: 0x228B22 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    // === LUMIÈRE ===
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(10, 20, 10);
    light.castShadow = true;
    light.shadow.mapSize.width = 2048;
    light.shadow.mapSize.height = 2048;
    scene.add(light);

    // === MURS (labyrinthe simple) ===
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
    const walls = [];

    function addWall(x, z, w, d) {
      const wall = new THREE.Mesh(new THREE.BoxGeometry(w, 3, d), wallMat);
      wall.position.set(x, 1.5, z);
      wall.castShadow = wall.receiveShadow = true;
      scene.add(wall);
      walls.push(wall);
    }

    addWall(0, 0, 12, 1);
    addWall(6, 6, 1, 12);
    addWall(-6, 6, 1, 12);
    addWall(0, 12, 12, 1);
    addWall(3, 8, 6, 1);

    // === MOUVEMENT ===
    const move = { forward: false, backward: false, left: false, right: false };
    const speed = 10;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    document.addEventListener('keydown', e => {
      switch (e.code) {
        case 'KeyW': move.forward = true; break;
        case 'KeyS': move.backward = true; break;
        case 'KeyA': move.left = true; break;
        case 'KeyD': move.right = true; break;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.code) {
        case 'KeyW': move.forward = false; break;
        case 'KeyS': move.backward = false; break;
        case 'KeyA': move.left = false; break;
        case 'KeyD': move.right = false; break;
      }
    });

    // === COLLISION BASIQUE ===
    function checkCollision() {
      const playerBox = new THREE.Box3().setFromObject(camera);
      for (const wall of walls) {
        if (playerBox.intersectsBox(new THREE.Box3().setFromObject(wall))) {
          return true;
        }
      }
      return false;
    }

    // === BOUCLE ===
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const delta = clock.getDelta();

      if (controls.isLocked) {
        velocity.x = velocity.z = 0;
        direction.z = Number(move.forward) - Number(move.backward);
        direction.x = Number(move.right) - Number(move.left);
        direction.normalize();

        if (move.forward || move.backward) velocity.z = -direction.z * speed * delta;
        if (move.left || move.right) velocity.x = -direction.x * speed * delta;

        const oldPos = camera.position.clone();
        controls.moveRight(velocity.x);
        controls.moveForward(velocity.z);

        if (checkCollision()) {
          camera.position.copy(oldPos);
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // === RESIZE ===
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>